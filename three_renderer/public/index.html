<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>3D Mermaid Render</title>
  <style>body{margin:0;overflow:hidden} #info{position:absolute;left:8px;top:8px;padding:8px;background:#fff8;border-radius:6px;z-index:10}</style>
  <!-- Use ES module builds to avoid MIME/type blocking for examples -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.152.2/build/three.module.js",
      "three/": "https://unpkg.com/three@0.152.2/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="info">3D render of Mermaid diagram — <a href="/model.obj" target="_blank">model.obj</a>
    &nbsp; <button id="toggle-labels">Toggle Labels</button>
    &nbsp; <button id="export-gltf">Export glTF</button>
    &nbsp; <span id="status" style="font-weight:600;margin-left:12px">initializing…</span>
  </div>
  <div id="nav" style="position:fixed;right:8px;top:8px;z-index:20;background:#fff;padding:8px;border-radius:6px;box-shadow:0 2px 6px rgba(0,0,0,.12);font-size:13px">
    <a href="viewer_gltf.html">3D Viewer</a> ·
    <a href="force_graph.html">Force Graph</a> ·
    <a href="treemap.html">Treemap</a> ·
    <a href="matrix_heatmap.html">Matrix</a>
  </div>
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';
    import { GLTFExporter } from 'https://unpkg.com/three@0.152.2/examples/jsm/exporters/GLTFExporter.js';
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(8, -12, 12);
    camera.lookAt(8,0,0);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const light = new THREE.DirectionalLight(0xffffff, 0.8);
    light.position.set(1,1,1).normalize();
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x909090));

    // Orbit controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.07;
    controls.screenSpacePanning = false;
    controls.minDistance = 0.5;
    controls.maxDistance = 200;
    controls.target.set(0,0,0);
    controls.update();
    // ensure touch and pointer events work consistently
    renderer.domElement.style.touchAction = 'none';

    // Minimal inline OBJ parser that groups by '# name' sections into separate meshes
    async function loadOBJGrouped(url){
      const txt = await (await fetch(url)).text();
      const verts = [];
      let currentName = 'mesh';
      const groups = [];
      groups.push({name: currentName, verts: [], faces: []});

      let globalVertIndex = 0; // to map original indices per group
      const globalVerts = [];
      for (const line of txt.split('\n')){
        const l = line.trim();
        if (!l) continue;
        if (l.startsWith('#')){
          currentName = l.substring(1).trim() || ('mesh' + groups.length);
          groups.push({name: currentName, verts: [], faces: []});
        } else if (l.startsWith('v ')){
          const parts = l.split(/\s+/).slice(1).map(Number);
          globalVerts.push(parts);
        } else if (l.startsWith('f ')){
          const parts = l.split(/\s+/).slice(1).map(p=>parseInt(p.split('/')[0],10));
          // assign this face to the latest group
          groups[groups.length-1].faces.push(parts);
        }
      }

      // Now create meshes per group by extracting referenced vertices
      const meshes = [];
      let vertexCounter = 0;
      for (const g of groups){
        if (g.faces.length === 0) continue;
        const used = new Set();
        for (const f of g.faces) for (const idx of f) used.add(idx-1);
        const indexMap = new Map();
        const localVerts = [];
        let i=0;
        for (const idx of Array.from(used).sort((a,b)=>a-b)){
          indexMap.set(idx, i++);
          localVerts.push(globalVerts[idx]);
        }

        const positions = [];
        for (const f of g.faces){
          for (let j=1;j+1<f.length;j++){
            const ia = indexMap.get(f[0]-1), ib = indexMap.get(f[j]-1), ic = indexMap.get(f[j+1]-1);
            const a = localVerts[ia], b = localVerts[ib], c = localVerts[ic];
            positions.push(a[0],a[1],a[2]);
            positions.push(b[0],b[1],b[2]);
            positions.push(c[0],c[1],c[2]);
          }
        }

        if (positions.length === 0) continue;
        const geometry = new THREE.BufferGeometry();
        const posArr = new Float32Array(positions);
        geometry.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
        geometry.computeVertexNormals();
        const material = new THREE.MeshStandardMaterial({color:0x6699cc, metalness:0.1, roughness:0.6});
        const mesh = new THREE.Mesh(geometry, material);
        geometry.computeBoundingBox();
        const bb = geometry.boundingBox;
        if (bb){
          const cx = (bb.min.x + bb.max.x)/2;
          const cy = (bb.min.y + bb.max.y)/2;
          const cz = (bb.min.z + bb.max.z)/2;
          mesh.position.set(-cx, -cy, -cz);
        }
        mesh.userData.label = g.name || 'node';
        scene.add(mesh);
        meshes.push(mesh);
      }
      return meshes;
    }

    // Create label sprite from text
    function makeLabel(text){
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const fontSize = 48;
      ctx.font = `${fontSize}px Arial`;
      const w = Math.ceil(ctx.measureText(text).width) + 20;
      canvas.width = w; canvas.height = fontSize + 20;
      ctx.fillStyle = 'rgba(255,255,255,0.9)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#222';
      ctx.font = `${fontSize}px Arial`;
      ctx.fillText(text, 10, fontSize - 6);
      const tex = new THREE.CanvasTexture(canvas);
      const mat = new THREE.SpriteMaterial({map:tex});
      // ensure labels render on top and remain readable
      mat.depthTest = false;
      mat.depthWrite = false;
      const sprite = new THREE.Sprite(mat);
      // scale up labels for readability
      sprite.scale.set((canvas.width/40), (canvas.height/40), 1);
      return sprite;
    }

    let labelOn = true;
    const labels = [];
    document.getElementById('toggle-labels').addEventListener('click', ()=>{
      labelOn = !labelOn;
      labels.forEach(l=> l.visible = labelOn);
    });

    // GLTF export
    document.getElementById('export-gltf').addEventListener('click', ()=>{
      const exporter = new GLTFExporter();
      const exportObj = new THREE.Group();
      scene.traverse(function(child){ if (child.isMesh) exportObj.add(child.clone()); });
      exporter.parse(exportObj, function(result){
        let output;
        if (result instanceof ArrayBuffer) output = result;
        else output = JSON.stringify(result, null, 2);
        const blob = new Blob([output], {type: 'application/octet-stream'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'model.glb'; a.click();
      }, {binary: false});
    });

    let modelMeshes = [];
    const statusEl = document.getElementById('status');
    statusEl.textContent = 'loading model...';
    loadOBJGrouped('/model.obj').then(ms=>{
      modelMeshes = ms;
      statusEl.textContent = `loaded ${ms.length} mesh(es)`;
      // attach labels and build overall bounds
      const overall = new THREE.Box3();
      for (const m of modelMeshes){
        overall.expandByObject(m);
        const sprite = makeLabel(m.userData.label || 'node');
        // place above mesh
        const bb = new THREE.Box3().setFromObject(m);
        const top = bb.max;
        sprite.position.set(top.x, top.y, top.z + 0.6);
        scene.add(sprite);
        labels.push(sprite);
      }
      if (ms.length === 0){
        statusEl.textContent = 'no meshes found in model.obj';
      } else {
        // fit camera to overall bounding box
        const sphere = overall.getBoundingSphere(new THREE.Sphere());
        if (sphere.radius > 0){
          const offset = sphere.radius * 2.2;
          const dir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
          const newPos = new THREE.Vector3().addVectors(sphere.center, dir.multiplyScalar(offset));
          camera.position.copy(newPos);
          controls.target.copy(sphere.center);
          controls.update();
        }
      }
    }).catch(e=>{ console.error('load err', e); statusEl.textContent = 'error loading model (see console)'; });

    function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', ()=>{ camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
  </script>
</body>
</html>
