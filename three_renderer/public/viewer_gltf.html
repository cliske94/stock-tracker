<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Three Renderer - glTF viewer</title>
  <style>body{margin:0;height:100vh}canvas{display:block;height:100vh;width:100%}</style>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="status" style="position:absolute;left:8px;top:8px;z-index:10;background:#fff;padding:8px;border-radius:6px;box-shadow:0 2px 6px rgba(0,0,0,.12)">Loading model.gltf...</div>
  <div id="controls" style="position:absolute;left:8px;top:72px;z-index:10;background:#fff;padding:8px;border-radius:6px;box-shadow:0 2px 6px rgba(0,0,0,.08);font-size:13px">
    <label for="viewMode">Mode:</label>
    <select id="viewMode"><option value="semantic">Semantic</option><option value="timeline">Timeline</option><option value="heatmap">Heatmap</option></select>
    <div id="timelineControls" style="margin-top:6px;display:none">
      <input type="range" id="timeSlider" min="0" max="100" value="0" style="width:160px"> <span id="timeLabel">—</span>
      <button id="playBtn">Play</button>
    </div>
  </div>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf7f7f7);
    const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(10,10,20);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);

    const light = new THREE.DirectionalLight(0xffffff, 0.9); light.position.set(10,20,10); scene.add(light);
    scene.add(new THREE.AmbientLight(0x888888));

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(6,0,0); controls.update();

    // Load a semantic JSON model and render typed 3D objects + clear labels
    async function loadSemanticModel(){
      const res = await fetch('model_meta.json');
      const meta = await res.json();
      document.getElementById('status').textContent = 'Loaded model metadata';

      // helper: color and geometry per type
      const typeStyles = {
        'Service': { color: 0x1f77b4, geom: 'cylinder' },
        'Deployment': { color: 0xff7f0e, geom: 'box' },
        'default': { color: 0x2ca02c, geom: 'box' }
      };

      function makeSprite(text, opts={}){
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const fontSize = opts.fontSize||48;
        ctx.font = `${fontSize}px sans-serif`;
        const padding = 12;
        const metrics = ctx.measureText(text);
        const w = Math.min(1200, Math.max(200, metrics.width + padding*2));
        const h = fontSize + padding*2;
        canvas.width = w; canvas.height = h;
        // background with slight transparency
        ctx.fillStyle = 'rgba(255,255,255,0.95)';
        ctx.fillRect(0,0,w,h);
        // border
        ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 4; ctx.strokeRect(2,2,w-4,h-4);
        ctx.fillStyle = 'black'; ctx.textBaseline='middle'; ctx.font = `${fontSize}px sans-serif`;
        ctx.fillText(text, padding, h/2);
        const tex = new THREE.CanvasTexture(canvas);
        tex.needsUpdate = true;
        const mat = new THREE.SpriteMaterial({ map: tex, depthTest: false });
        const sp = new THREE.Sprite(mat);
        sp.scale.set(w/200, h/200, 1);
        sp.renderOrder = 999;
        return sp;
      }

      // legend
      (function createLegend(){
        const box = document.createElement('div');
        box.style.position = 'absolute'; box.style.right='8px'; box.style.top='8px'; box.style.zIndex=20;
        box.style.background='rgba(255,255,255,0.9)'; box.style.padding='8px'; box.style.borderRadius='6px'; box.style.fontSize='13px';
        box.innerHTML = '<b>Legend</b><br><span style="color:#1f77b4">■</span> Service &nbsp; <span style="color:#ff7f0e">■</span> Deployment';
        document.body.appendChild(box);
      })();

      // create objects
      const nodeMap = {};
      for(const n of meta.nodes){
        const [x,y,z] = n.position;
        // guess language/path for richer coloring and repo links
        function guessPathAndLang(n){
          const id = (n.id||'').toLowerCase();
          const name = (n.name||'').toLowerCase();
          if(name.includes('django')||name.includes('helpsite')||id.includes('help')) return { path:'helpsite', lang:'python' };
          if(name.includes('spring')||id.includes('spring')) return { path:'spring_hello_world', lang:'java' };
          if(name.includes('cpp')||id.includes('cpp')||name.includes('c++')) return { path:'cpp_stock_ui', lang:'cpp' };
          if(name.includes('python')||id.includes('python')||name.includes('watchlist')) return { path:'python_watchlist_gui', lang:'python' };
          if(name.includes('dashboard')) return { path:'dashboard_service', lang:'python' };
          if(name.includes('log')||id.includes('log')) return { path:'tools/log_collector', lang:'python' };
          if(id.includes('three')||name.includes('three')) return { path:'three_renderer', lang:'javascript' };
          return { path: n.id, lang: 'unknown' };
        }
        const guess = guessPathAndLang(n);
        const style = n.type && typeStyles[n.type] ? typeStyles[n.type] : typeStyles['default'];
        let mesh;
        if(style.geom === 'cylinder'){
          const geom = new THREE.CylinderGeometry(0.7,0.7,1.6,16);
          mesh = new THREE.Mesh(geom, new THREE.MeshStandardMaterial({color: style.color}));
        } else {
          const geom = new THREE.BoxGeometry(1.6,1.6,1.6);
          mesh = new THREE.Mesh(geom, new THREE.MeshStandardMaterial({color: style.color}));
        }
        mesh.position.set(x,y,z);
        scene.add(mesh);
        mesh.userData.meta = n;
        mesh.userData.repo = guess.path;
        mesh.userData.lang = guess.lang;
        nodeMap[n.id] = mesh;

        const labelText = n.name && n.name.length? n.name : n.id;
        const sprite = makeSprite(labelText, {fontSize:36});
        sprite.position.set(x, y+1.3, z);
        sprite.userData.basePos = sprite.position.clone();
        sprite.userData.meta = n;
        scene.add(sprite);
      }

      // edges
      for(const e of meta.edges){
        const a = nodeMap[e.from];
        const b = nodeMap[e.to];
        if(!a || !b) continue;
        const pts = [ new THREE.Vector3().copy(a.position), new THREE.Vector3().copy(b.position) ];
        const geom = new THREE.BufferGeometry().setFromPoints(pts);
        const line = new THREE.Line(geom, new THREE.LineBasicMaterial({color:0x333333, linewidth:2}));
        scene.add(line);
        if(e.label){
          const mid = new THREE.Vector3().addVectors(pts[0], pts[1]).multiplyScalar(0.5).add(new THREE.Vector3(0,0.7,0));
          const l = makeSprite(e.label, {fontSize:30}); l.position.copy(mid); scene.add(l);
        }
      }

      // auto-fit camera to all nodes
      const group = new THREE.Group();
      for(const m of Object.values(nodeMap)) group.add(m);
      const box = new THREE.Box3().setFromObject(group);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3()).length();
      const dist = Math.max(10, size * 1.5);
      camera.position.copy(center).add(new THREE.Vector3(dist, dist, dist));
      controls.target.copy(center);
      document.getElementById('status').textContent = 'Rendered semantic model';
      // improved label placement using simple iterative repulsion in screen-space
      function adjustLabelsIterative(iterations=6){
        const sprites = [];
        for(const obj of scene.children){ if(obj.type==='Sprite') sprites.push(obj); }
        for(let it=0; it<iterations; it++){
          const rects = sprites.map(s => {
            const pos = new THREE.Vector3(); s.getWorldPosition(pos);
            pos.project(camera);
            const sx = (pos.x * 0.5 + 0.5) * renderer.domElement.width;
            const sy = ( -pos.y * 0.5 + 0.5) * renderer.domElement.height;
            const w = (s.scale.x*200); const h = (s.scale.y*200);
            return { s, sx, sy, w, h };
          });
          for(let i=0;i<rects.length;i++){
            for(let j=i+1;j<rects.length;j++){
              const a = rects[i], b = rects[j];
              const dx = a.sx - b.sx; const dy = a.sy - b.sy;
              const overlapX = (a.w+b.w)/2 - Math.abs(dx);
              const overlapY = (a.h+b.h)/2 - Math.abs(dy);
              if(overlapX>0 && overlapY>0){
                // move sprites in opposite directions in world space along screen-to-world vector
                const signX = dx===0? (Math.random()>0.5?1:-1) : Math.sign(dx);
                const signY = dy===0? -1 : Math.sign(dy);
                const shiftScreenX = signX * overlapX * 0.5;
                const shiftScreenY = signY * overlapY * 0.5;
                // convert screen shift to world shift at sprite depth
                const sPos = new THREE.Vector3(); a.s.getWorldPosition(sPos);
                const ndc = sPos.clone().project(camera);
                const targetNdc = new THREE.Vector3(
                  ndc.x + (shiftScreenX / renderer.domElement.width)*2,
                  ndc.y - (shiftScreenY / renderer.domElement.height)*2,
                  ndc.z
                );
                // unproject back to world
                const un = new THREE.Vector3(targetNdc.x, targetNdc.y, targetNdc.z).unproject(camera);
                const worldShift = un.sub(sPos).multiplyScalar(0.6);
                a.s.position.add(worldShift);
                a.s.userData.basePos = a.s.position.clone();
              }
            }
          }
        }
      }

      // hover/click tooltips and click-to-copy path
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      const tooltip = document.createElement('div');
      tooltip.style.position='absolute'; tooltip.style.pointerEvents='none'; tooltip.style.background='rgba(255,255,240,0.95)'; tooltip.style.padding='8px'; tooltip.style.border='1px solid rgba(0,0,0,0.1)'; tooltip.style.borderRadius='6px'; tooltip.style.display='none'; tooltip.style.zIndex=30; tooltip.style.fontSize='13px';
      document.body.appendChild(tooltip);

      function findIntersect(event){
        const rect = renderer.domElement.getBoundingClientRect();
        const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        mouse.set(x,y);
        raycaster.setFromCamera(mouse, camera);
        const meshes = Object.values(nodeMap);
        const ints = raycaster.intersectObjects(meshes, false);
        return ints.length? ints[0].object : null;
      }

      let lastHover = null;
      renderer.domElement.addEventListener('mousemove', (ev)=>{
        const hit = findIntersect(ev);
        if(hit !== lastHover){
          if(lastHover) lastHover.material.emissive && (lastHover.material.emissive.setHex(0x000000));
          lastHover = hit;
          if(hit){ hit.material.emissive && hit.material.emissive.setHex(0x222222); }
        }
        if(hit){
          const meta = hit.userData.meta || {};
          const repo = hit.userData.repo || '';
          tooltip.innerHTML = `<b>${meta.name||meta.id}</b><br>type: ${meta.type||'n/a'}<br>path: ${repo}`;
          tooltip.style.left = (ev.clientX+12)+'px'; tooltip.style.top = (ev.clientY+12)+'px'; tooltip.style.display='block';
        } else { tooltip.style.display='none'; }
      });

      renderer.domElement.addEventListener('click', (ev)=>{
        const hit = findIntersect(ev);
        if(hit){
          const repo = hit.userData.repo || hit.userData.meta && hit.userData.meta.id || '';
          navigator.clipboard && navigator.clipboard.writeText(repo).then(()=>{
            document.getElementById('status').textContent = 'Copied path: '+repo;
            setTimeout(()=>document.getElementById('status').textContent='Rendered semantic model', 2500);
          }).catch(()=>{ document.getElementById('status').textContent = 'Path: '+repo; });
        }
      });

      // adjust on controls change and resize once
      controls.addEventListener('change', () => setTimeout(()=>adjustLabelsIterative(6), 10));
      window.addEventListener('resize', () => setTimeout(()=>adjustLabelsIterative(6), 20));
      setTimeout(()=>adjustLabelsIterative(6), 50);
    }

    loadSemanticModel().catch(e => { console.warn('semantic load failed', e); document.getElementById('status').textContent = 'Semantic load failed'; });

    // Timeline and Heatmap support
    let timeData = null;
    let metricsData = null;
    let playing = false; let playHandle = null;

    async function loadTimeAndMetrics(){
      try { const r = await fetch('model_meta_time.json'); if (r.ok) timeData = await r.json(); }
      catch(e) { /* no time data */ }
      try { const r2 = await fetch('model_meta_metrics.json'); if (r2.ok) metricsData = await r2.json(); }
      catch(e) { /* no metrics */ }
    }
    loadTimeAndMetrics();

    function applyTimeToNodes(perc){
      if(!timeData) return;
      // Determine time range
      const allTs = [].concat(...timeData.nodes.map(n => (n.history||[]).map(h=>h.ts)));
      if(allTs.length===0) return;
      const minTs = Math.min(...allTs), maxTs = Math.max(...allTs);
      const t = Math.floor(minTs + (maxTs-minTs)*(perc/100));
      document.getElementById('timeLabel').textContent = new Date(t*1000).toISOString().replace(/T.*/,'');
      // apply as scale/brightness proportional to cumulative weight up to t
      for(const mid in window.nodeMap){
        const mesh = window.nodeMap[mid];
        const ninfo = (timeData.nodes||[]).find(x=>x.id===mid) || { history: [] };
        const weight = (ninfo.history||[]).filter(h=>h.ts<=t).reduce((s,h)=>s+h.weight,0);
        const scale = 1 + Math.min(4, weight/3);
        mesh.scale.set(scale, scale, scale);
        if(mesh.material && mesh.material.color){
          mesh.material.emissive && mesh.material.emissive.setScalar(Math.min(1, weight/6));
        }
      }
    }

    function applyHeatmap(){
      if(!metricsData) return;
      // compute max loc for normalization
      const maxLoc = Math.max(1, ...(metricsData.nodes||[]).map(n=>n.loc||0));
      for(const mid in window.nodeMap){
        const mesh = window.nodeMap[mid];
        const m = (metricsData.nodes||[]).find(x=>x.id===mid) || { loc:0, imports:0 };
        const norm = Math.min(1, (m.loc||0)/maxLoc);
        // color: blue->red
        const r = Math.floor(255*norm), b = Math.floor(255*(1-norm)), g = 80;
        if(mesh.material && mesh.material.color){ mesh.material.color.setRGB(r/255, g/255, b/255); }
        const scale = 1 + Math.log10((m.loc||0)+1);
        mesh.scale.set(scale, scale, scale);
      }
    }

    // UI wiring
    document.getElementById('viewMode').addEventListener('change', (ev)=>{
      const v = ev.target.value;
      document.getElementById('timelineControls').style.display = v==='timeline'? 'block' : 'none';
      if(v==='heatmap'){ applyHeatmap(); }
      if(v==='semantic'){ /* reset sizes/colors by reloading the page or re-render */ window.location.reload(); }
    });

    const slider = document.getElementById('timeSlider');
    slider.addEventListener('input', ()=>{ applyTimeToNodes(Number(slider.value)); });
    document.getElementById('playBtn').addEventListener('click', ()=>{
      if(playing){ playing=false; document.getElementById('playBtn').textContent='Play'; clearInterval(playHandle); }
      else{ playing=true; document.getElementById('playBtn').textContent='Stop'; playHandle=setInterval(()=>{ const v=Number(slider.value); const nv = (v+2)%101; slider.value=nv; applyTimeToNodes(nv); }, 300); }
    });

    function animate(){ requestAnimationFrame(animate); renderer.render(scene,camera); }
    window.addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });
    animate();
  </script>
</body>
</html>
