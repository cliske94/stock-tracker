<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Dashboard - Service Metrics</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:20px}#controls{margin-bottom:12px}</style>
  </head>
  <body>
    <h1>Service Metrics Dashboard</h1>
    <div id="controls">
      <label for="svc">Service:</label>
      <select id="svc"></select>
      <button id="refresh">Refresh</button>
      <span id="any-status" style="margin-left:12px;font-weight:600;color:gray">Any service up: unknown</span>
    </div>
    <canvas id="chart" width="800" height="300"></canvas>
    <script>
      async function loadServices(){
        try{
          const res = await fetch('/api/services');
          if(!res.ok) return [];
          return await res.json();
        }catch(e){
          console.error('loadServices error', e);
          return [];
        }
      }
      async function loadSeries(svc){
        const res = await fetch('/api/series?service='+encodeURIComponent(svc));
        return res.json();
      }
      function toLabels(data){return data.map(d=>new Date(d.ts*1000).toLocaleTimeString())}
      function toData(data, key){return data.map(d=>d[key])}

      let chart=null;
      async function render(){
        const svc = document.getElementById('svc').value;
        if(!svc) return;
        const series = await loadSeries(svc);
        const labels = toLabels(series);
        const uptime = toData(series,'uptime');
        const requests = toData(series,'requests');
        const ctx = document.getElementById('chart').getContext('2d');
        const datasets = [
          {label:'Uptime (s)', data:uptime, borderColor:'blue', yAxisID:'y1'},
          {label:'Requests', data:requests, borderColor:'green', yAxisID:'y2'}
        ];
        if(chart) chart.destroy();
        chart = new Chart(ctx, {type:'line', data:{labels, datasets}, options:{scales:{y1:{position:'left'}, y2:{position:'right'}}}});
      }

      document.getElementById('refresh').addEventListener('click', render);

      async function updateAnyStatus(){
        try{
          const res = await fetch('/api/latest');
          if(!res.ok) return;
          const data = await res.json();
          const now = Math.floor(Date.now()/1000);
          const thresh = 90; // seconds â€” consider service up if last seen within this window
          let anyUp = false;
          Object.keys(data).forEach(k=>{ const ts = data[k] && data[k].ts ? data[k].ts : 0; if(now - ts <= thresh) anyUp = true; });
          const el = document.getElementById('any-status');
          el.textContent = anyUp ? 'Any service up: Yes' : 'Any service up: No';
          el.style.color = anyUp ? 'green' : 'red';
        }catch(e){ console.error('updateAnyStatus error', e); }
      }

      async function populateServices(){
        const svcs = await loadServices();
        const sel = document.getElementById('svc');
        sel.innerHTML = '';
        svcs.forEach(s=>{const o=document.createElement('option'); o.value=s; o.textContent=s; sel.appendChild(o)});
        if(svcs.length) { sel.value=svcs[0]; await render(); }
      }

      // initial populate and periodic refresh so dropdown reflects recent ingests
      (async ()=>{
        await populateServices();
        await updateAnyStatus();
        setInterval(()=>{ populateServices(); updateAnyStatus(); }, 15000);
        // fallback short-poll to detect ingests even if SSE is unavailable
        let _lastLatest = null;
        async function pollLatest(){
          try{
            const res = await fetch('/api/latest');
            if(!res.ok) return;
            const data = await res.json();
            const asStr = JSON.stringify(data);
            if(_lastLatest && _lastLatest !== asStr){
              // change detected
              populateServices();
              updateAnyStatus();
              const sel = document.getElementById('svc'); if(sel && sel.value) render();
            }
            _lastLatest = asStr;
          }catch(e){/*ignore*/}
        }
        setInterval(pollLatest, 3000);
        // listen for server-sent events and refresh immediately on ingest
        function setupSSE(){
          try{
            const es = new EventSource('/events');
            es.onmessage = function(e){
              try{ const msg = JSON.parse(e.data); console.log('sse',msg); }catch(err){}
              // refresh small parts instead of full reload
              populateServices();
              updateAnyStatus();
              const sel = document.getElementById('svc');
              if(sel && sel.value) render();
            };
            es.onerror = function(){
              // attempt reconnect by recreating EventSource after a short delay
              es.close();
              setTimeout(setupSSE, 3000);
            };
          }catch(err){ console.warn('SSE not supported', err); }
        }
        setupSSE();
      })();
    </script>
  </body>
</html>
